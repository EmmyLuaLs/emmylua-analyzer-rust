nil: |
  *nil* 类型只有一个值 **nil**，其主要特性是与任何其他值都不同；
  它通常表示缺少有用的值。

boolean: |
  *boolean* 类型有两个值：**false** 和 **true**。**nil** 和 **false**
  都会使条件为假；任何其他值都会使条件为真。

number: |
  *number* 类型使用两种内部表示，或两个子类型，一个称为 *integer*，
  另一个称为 *float*。Lua 对何时使用哪种表示有明确的规则，但它也会
  根据需要在两者之间自动转换。因此，程序员可以选择大部分时候忽略整数
  和浮点数之间的差异，或者完全控制每个数字的表示。标准 Lua 使用64位
  整数和双精度（64位）浮点数，但你也可以编译 Lua 使其使用32位整数
  和/或单精度（32位）浮点数。对于小型机器和嵌入式系统，整数和浮点数
  都使用32位的选项特别有吸引力。（参见 luaconf.h 文件中的宏 LUA_32BITS。）

userdata: |
  *userdata* 类型用于允许将任意 C 数据存储在 Lua 变量中。userdata 值
  表示一块原始内存。有两种 userdata：*完全 userdata*，是一个由 Lua
  管理内存块的对象；*轻量 userdata*，仅是一个 C 指针值。userdata 在
  Lua 中没有预定义的操作，除了赋值和身份测试。通过使用 *元表*，程序员
  可以为完全 userdata 值定义操作。userdata 值不能在 Lua 中创建或修改，
  只能通过 C API 进行。这保证了宿主程序所拥有数据的完整性。

thread: |
  *thread* 类型表示独立的执行线程，用于实现协程。Lua 线程与操作系统
  线程无关。Lua 在所有系统上都支持协程，即使是那些原生不支持线程的系统。

table: |
  *table* 类型实现关联数组，即索引不仅可以是数字，还可以是除 **nil**
  和 NaN 之外的任何 Lua 值的数组。（*NaN* 是 IEEE 754 标准用于表示
  未定义或不可表示的数值结果的特殊浮点值，例如 `0/0`。）表可以是异构的；
  也就是说，它们可以包含所有类型的值（除了 **nil**）。值为 **nil** 的
  任何键都不被视为表的一部分。相反，不属于表的任何键都有一个关联值 **nil**。

  表是 Lua 中唯一的数据组织机制；它们可以用来表示普通数组、列表、符号表、
  集合、记录、图、树等。为了表示记录，Lua 使用字段名作为索引。语言通过
  提供 `a.name` 作为 `a["name"]` 的语法糖来支持这种表示。在 Lua 中有
  几种方便的方式来创建表。

  与索引一样，表字段的值可以是任何类型。特别是，由于函数是一等值，表
  字段可以包含函数。因此表也可以携带 *方法*。

  表的索引遵循语言中原始相等的定义。表达式 `a[i]` 和 `a[j]` 当且仅当
  `i` 和 `j` 原始相等（即不使用元方法的相等）时表示相同的表元素。特别地，
  具有整数值的浮点数等于其对应的整数。为避免歧义，任何用作键的具有整数值
  的浮点数都会转换为其对应的整数。例如，如果你写 `a[2.0] = true`，
  插入表中的实际键将是整数 `2`。（另一方面，2 和 "`2`" 是不同的 Lua 值，
  因此表示不同的表条目。）

std.Select: |
  Select 函数的内置类型

std.Unpack: |
  Unpack 函数的内置类型

std.RawGet: |
  Rawget 的内置类型

std.ConstTpl: |
  泛型模板的内置类型，用于匹配整数常量和 true/false

Parameters: |
  以元组形式获取函数的参数

ConstructorParameters: |
  以元组形式获取构造函数的参数

Partial: |
  使 T 中的所有属性变为可选
